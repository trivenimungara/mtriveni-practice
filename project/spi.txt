               SPI-BASED REAL-TIME DHT11 SENSOR DATA TRANSMISSION BETWEEN STM32 MICROCONTROLLERS WITH UART DISPLAY

ABSTRACT:

This project implements a real-time temperature and humidity monitoring system using the DHT11 sensor and STM32 microcontrollers. The sensor data is acquired by an SPI master STM32 and transmitted to an SPI slave STM32 using SPI communication. The received data is then sent to a PC through UART and displayed on a terminal(Minicom). The project demonstrates effective sensor interfacing, inter-microcontroller communication, and serial data visualization using standard embedded communication protocols.

1.MASTER(STM32)CODE:

#include "stm32f4xx_hal.h"
#include "dht11.h"
#include <stdio.h>

/* HAL Handles */
SPI_HandleTypeDef hspi1;
TIM_HandleTypeDef htim1;

/* Prototypes */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI1_Init(void);
static void MX_TIM1_Init(void);

int main(void)
{
    uint8_t temp = 0, hum = 0;
    uint8_t dummy;
    char msg[40];

    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_SPI1_Init();
    MX_TIM1_Init();

    HAL_TIM_Base_Start(&htim1);

    while (1)
    {
        DHT11_Read_Data(&temp, &hum);

        sprintf(msg, "TEMP=%d HUM=%d\r\n", temp, hum);

        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);

        for (int i = 0; msg[i] != '\0'; i++)
        {
            HAL_SPI_TransmitReceive(&hspi1,(uint8_t *)&msg[i],&dummy,1, HAL_MAX_DELAY);
        }

        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);

        HAL_Delay(2000);
    }
}

/* ================= CLOCK ================= */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef osc = {0};
    RCC_ClkInitTypeDef clk = {0};

    __HAL_RCC_PWR_CLK_ENABLE();

    osc.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    osc.HSIState = RCC_HSI_ON;
    osc.PLL.PLLState = RCC_PLL_NONE;
    HAL_RCC_OscConfig(&osc);

    clk.ClockType = RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_HCLK |RCC_CLOCKTYPE_PCLK1 |RCC_CLOCKTYPE_PCLK2;
    clk.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
    clk.AHBCLKDivider = RCC_SYSCLK_DIV1;
    clk.APB1CLKDivider = RCC_HCLK_DIV1;
    clk.APB2CLKDivider = RCC_HCLK_DIV1;
    HAL_RCC_ClockConfig(&clk, FLASH_LATENCY_0);
}

/* ================= GPIO ================= */
static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef g = {0};

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /* PA1 - DHT11 */
    g.Pin = GPIO_PIN_1;
    g.Mode = GPIO_MODE_OUTPUT_PP;
    g.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &g);

    /* PA4 - SPI NSS */
    g.Pin = GPIO_PIN_4;
    g.Mode = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOA, &g);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
}

/* ================= SPI ================= */
static void MX_SPI1_Init(void)
{
    __HAL_RCC_SPI1_CLK_ENABLE();

    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_MASTER;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi1.Init.NSS = SPI_NSS_SOFT;
    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    HAL_SPI_Init(&hspi1);
}

/* ================= TIMER ================= */
static void MX_TIM1_Init(void)
{
    __HAL_RCC_TIM1_CLK_ENABLE();

    htim1.Instance = TIM1;
    htim1.Init.Prescaler = 15;   // 16 MHz / 16 = 1 Âµs
    htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim1.Init.Period = 65535;
    HAL_TIM_Base_Init(&htim1);
}
 
2.Core/Inc/dht11.h:

#ifndef __DHT11_H
#define __DHT11_H

#include "stm32f4xx_hal.h"

void DHT11_Read_Data(uint8_t *temp, uint8_t *hum);

#endif

3.Core/Src/dht11.c:

#include "dht11.h"

#define DHT_PORT GPIOA
#define DHT_PIN  GPIO_PIN_1

extern TIM_HandleTypeDef htim1;

static void delay_us(uint16_t us)
{
    __HAL_TIM_SET_COUNTER(&htim1, 0);
    while (__HAL_TIM_GET_COUNTER(&htim1) < us);
}

void DHT11_Read_Data(uint8_t *temp, uint8_t *hum)
{
    uint8_t data[5] = {0};
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* OUTPUT */
    GPIO_InitStruct.Pin = DHT_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(DHT_PORT, &GPIO_InitStruct);

    HAL_GPIO_WritePin(DHT_PORT, DHT_PIN, GPIO_PIN_RESET);
    HAL_Delay(18);
    HAL_GPIO_WritePin(DHT_PORT, DHT_PIN, GPIO_PIN_SET);
    delay_us(30);

    /* INPUT */
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    HAL_GPIO_Init(DHT_PORT, &GPIO_InitStruct);

    while (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN));
    while (!HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN));
    while (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN));

    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 8; j++)
        {
            while (!HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN));
            delay_us(40);
            if (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN))
                data[i] |= (1 << (7 - j));
            while (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN));
        }
    }

    if (data[4] == (data[0] + data[1] + data[2] + data[3]))
    {
        *hum  = data[0];
        *temp = data[2];
    }
}

4.SLAVE(STM32) CODE:

#include "main.h"

/* Private variables */
SPI_HandleTypeDef hspi1;
UART_HandleTypeDef huart2;

/* Private function prototypes */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI1_Init(void);
static void MX_USART2_UART_Init(void);

#define RX_BUFFER_SIZE 50

int main(void)
{
    uint8_t rx;
    char buffer[RX_BUFFER_SIZE];
    uint8_t index = 0;

    HAL_Init();
    SystemClock_Config();

    MX_GPIO_Init();
    MX_SPI1_Init();
    MX_USART2_UART_Init();

    char startMsg[] = "SPI UART Ready\r\n";
    HAL_UART_Transmit(&huart2, (uint8_t *)startMsg, sizeof(startMsg)-1, 100);

    while (1)
    {
        if (HAL_SPI_Receive(&hspi1, &rx, 1, 100) == HAL_OK)
        {
            if (index < RX_BUFFER_SIZE - 1)
                buffer[index++] = rx;
            else
                index = 0;

            if (rx == '\n')
            {
                buffer[index - 1] = '\r';
                buffer[index++] = '\n';
                buffer[index] = '\0';


                HAL_UART_Transmit(&huart2, (uint8_t *)buffer, index, 100);
                index = 0;
            }
        }
    }
}

/* ================= CLOCK CONFIG ================= */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
    RCC_OscInitStruct.PLL.PLLM = 16;
    RCC_OscInitStruct.PLL.PLLN = 336;
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
    RCC_OscInitStruct.PLL.PLLQ = 7;

    HAL_RCC_OscConfig(&RCC_OscInitStruct);

    RCC_ClkInitStruct.ClockType =
        RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
        RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

    HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
}

/* ================= GPIO ================= */
static void MX_GPIO_Init(void)
{
    __HAL_RCC_GPIOA_CLK_ENABLE();
}

/* ================= SPI1 SLAVE ================= */
static void MX_SPI1_Init(void)
{
    __HAL_RCC_SPI1_CLK_ENABLE();

    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_SLAVE;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi1.Init.NSS = SPI_NSS_HARD_INPUT;
    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
    hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;

    HAL_SPI_Init(&hspi1);
}

/* ================= UART2 ================= */
static void MX_USART2_UART_Init(void)
{
    __HAL_RCC_USART2_CLK_ENABLE();

    huart2.Instance = USART2;
    huart2.Init.BaudRate = 115200;
    huart2.Init.WordLength = UART_WORDLENGTH_8B;
    huart2.Init.StopBits = UART_STOPBITS_1;
    huart2.Init.Parity = UART_PARITY_NONE;
    huart2.Init.Mode = UART_MODE_TX_RX;
    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;

    HAL_UART_Init(&huart2);
}

5.FLASHING ORDER:

>SLAVE FLASH AND RESET
>MASTER FLASH AND RESET
